---
title: "Configuring OpenAPI"
group: "REST API"
groupOrder: 0
---

# Configuring OpenAPI

To expose your server actions as RESTful endpoints in your application, we recommend using `zsa-openapi`. This ensures adherence to OpenAPI standards. 

<Info>
The functionality of `zsa-openapi` is heavily inspired by and built upon the work done in [trpc-openapi](https://github.com/jlalmes/trpc-openapi). We owe a lot of credit to `trpc-openapi` for making this possible.
</Info>

## RESTful Endpoints

All server actions that you create can be exposed as RESTful endpoints using `zsa-openapi`. To get started, run:

```bash:terminal
npm i zsa-openapi
```

Next, define your desired server actions.

```typescript:actions.ts
"use server"

import { z } from "zod"
import { createServerAction } from "zsa"

export const createPost = createServerAction()
    .input(z.object({ message: z.string() }))
    .handler(async ({ input }) => {
        // add your logic here
    })

export const updatePost = createServerAction()
    .input(z.object({ postId: z.string(), message: z.string() }))
    .handler(async ({ input }) => {
        // add your logic here
    })

export const getReply = createServerAction()
    .input(z.object({ postId: z.string(), replyId: z.string(), message: z.string() }))
    .handler(async ({ input }) => {
        // add your logic here
    })
```

Now that you have your server actions, create an OpenAPI router and expose these actions as endpoints in your application. To do this in your Next.js application, create a route at `/api/[[...openapi]]/route.ts`:

```typescript:api/[[...openapi]]/route.ts
import { createOpenApiServerActionRouter, createRouteHandlers } from "zsa-openapi"
import { createPost, updatePost, getReply, getPosts } from "./actions"

const router = createOpenApiServerActionRouter({   <|highlight|>
    pathPrefix: "/api", 
})
    .get("/posts", getPosts, {   <|highlight|>
        tags: ["posts"],
    })
    .post("/posts", createPost, {   <|highlight|>
        tags: ["posts"],
    })
    .put("/posts/{postId}", updatePost, {   <|highlight|>
        tags: ["posts"],
    })
    .get("/posts/{postId}/replies/{replyId}", getReply, {   <|highlight|>
        tags: ["replies"],
    })

export const { GET, POST, PUT } = createRouteHandlers(router) <|highlight|>
```

Ensure that your `pathPrefix` matches the prefix to your `/[[...openapi]]/route.ts` path.

You can now hit your server actions at the configured paths. Your server actions will take the path parameters defined in your router as input to the action.

<Note>
Anything not defined as a path parameter but required in the server action input will be required in the query parameters for that endpoint. 
</Note>

<Warning>
We recommend that all methods in your `createOpenApiServerActionRouter` are configured directly in a singular file rather than across multiple files. If you export the route handlers in one file and chain your routes (`router.get`) in another file, these routes will not be accessible. They must be consolidated into your `api/[[...openapi]]/route.ts` file. 
</Warning>

## OpenAPI Documentation

`zsa-openapi` allows you to take your RESTful API router and automatically generate valid, industry-standard OpenAPI documentation (OAS-compliant structure).

To do this in Next.js, start by creating an endpoint at `/doc/route.ts`:

```typescript:docs/page.tsx
import SwaggerUI from "swagger-ui-react" <|highlight|>
import "swagger-ui-react/swagger-ui.css"
import { generateOpenApiDocument } from "zsa-openapi" <|highlight|>
import { router } from "../api/[[...openapi]]/route"

export default async function DocsPage() {
  const spec = await generateOpenApiDocument(router, {
    title: "ZSA OpenAPI",
    version: "1.0.0",
    baseUrl: "http://localhost:3000",
  })

  return <SwaggerUI spec={spec} />
}
```

If you hit this endpoint, you should have access to your API documentation in OAS-compliant structure. Here is an example of the outputted structured docs: [Swagger Editor](/docs).

<img src="/swagger.png" alt="swagger" />

## Single endpoints

Additionally, if you only want to expose a single server action as an endpoint, you can use `setupApiHandler`. This is good when you want to create adhoc route heandlers. For example:

```typescript:api/adhoc-example/route.ts
import { setupApiHandler } from "zsa-openapi"; <|highlight|>
import { getReply } from "./actions";

export const { GET } = setupApiHandler("/posts/{postId}/replies/{replyId}", getReply) <|highlight|>
```

## Authentication

If you expose your server actions using `createOpenApiServerActionRouter` or `setupApiHandler`, then the `NextRequest` object will automatically be available in your defined actions and procedures. For example:

```typescript:actions.ts
"use server"

import { z } from "zod"
import { createServerAction } from "zsa"

export const getReplyWithHeaders = createServerAction()
    .input(
        z.object({ postId: z.string(), replyId: z.string(), message: z.string() })
    )
    .handler(async ({ input, request }) => { <|highlight|>
        if (request) {
            // authenticate with headers
            const apiKey = request.headers.get("authorization")?.split(" ")[1] <|highlight|>

            if (!apiKey || apiKey !== "123") {
                throw new Error("NOT_AUTHORIZED")
            }

            return {
                user: {
                    id: 123,
                    name: "test",
                },
            }
        } else {
            // authenticate with cookies
            const user = await auth()

            return {
                user
            }
        }
    })
```

In this example, the request object represents the incoming HTTP request. You can access various properties and methods of the request object, such as headers, to retrieve information from the request.
